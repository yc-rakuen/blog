{"title":"Git基础操作","date":"2018-02-09T03:05:50.986Z","excerpt":"","slug":"Git基本操作笔记","comments":true,"tags":["Git"],"categories":["版本管理"],"updated":"2018-03-15T16:00:00.000Z","content":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>首先要安装<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"noopener\">客户端</a>，Win/OSX/Linux对应不同的文件，安装过程比较简单，不再细说。</p>\n<p><a href=\"https://git-scm.com/downloads/guis\" target=\"_blank\" rel=\"noopener\">图形界面推荐</a>，sourcetree界面美观提示友好，不过安装过程需要翻墙注册账号。</p>\n<p>安装完成后，首先应配置用户信息，每一次代码提交都会用到这些用户信息。如果命令加上<code>--global</code>参数，那么只需要配置一次，当前系统内的所有仓库如果不单独配置，都会使用这个配置。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config user.name &quot;ahahaha&quot;</span><br><span class=\"line\">$ git config user.email email@ooo.xxx</span><br></pre></td></tr></table></figure></p>\n<p>其他配置参考<a href=\"https://git-scm.com/book/zh/v2/Appendix-C%3A-Git-%E5%91%BD%E4%BB%A4-%E8%AE%BE%E7%BD%AE%E4%B8%8E%E9%85%8D%E7%BD%AE\" target=\"_blank\" rel=\"noopener\">官方文档</a>。</p>\n<h2 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h2><p>与传统的针对单个文件记录历史类型的版本管理工具(比如SVN)相比，Git更像是把数据看作是对小型文件系统的一组<code>快照</code>。在每次提交更新，或在 Git 中保存项目状态时，它主要对当时的<code>全部文件</code>制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个<code>快照流</code>。因此，复制远程版本库使用的命令是<code>clone</code>而非<code>check out</code><br>Git是一个<strong>分布式</strong>的版本控制工具，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。本地仓库与远程仓库的地位是同等的，都保存了完整的历史，这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。</p>\n<p>Git管理的项目有三个<code>区域</code>，对应三种<code>状态</code>：<br><strong>工作区</strong><br>    工作区是对项目的某个版本独立提取出来的内容。如果修改了Git已跟踪的文件，Git会将该文件记录为<code>已修改</code>状态。  </p>\n<p><strong>暂存区</strong><br>    暂存区域是一个文件，保存了下次将提交的文件列表信息。暂存已修改的文件，Git会对修改后的文件进行<code>快照</code>，文件就会被保存到此区域，成为<code>已暂存</code>状态。 已暂存状态表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 </p>\n<p><strong>仓库</strong><br>    仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。提交已暂存的文件，Git将保存在暂存区域的文件快照永久转储到仓库，文件变为<code>已提交</code>状态，正式进入版本库。  </p>\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><p>以下命令中，<code>[]</code>部分是必填参数，<code>&lt;&gt;</code>部分是可选参数</p>\n<h3 id=\"获取代码仓库\"><a href=\"#获取代码仓库\" class=\"headerlink\" title=\"获取代码仓库\"></a>获取代码仓库</h3><p>建立仓库时可选择两种方式：</p>\n<ol>\n<li>新建一个空白仓库<code>git init</code></li>\n<li>从已存在的仓库克隆一份<code>git clone</code><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git init &lt;project-name&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>执行该命令，Git会在指定的<code>project-name</code>目录会创建一个空的新代码仓库，如果不填写<code>project-name</code>，则会在当前目录下创建仓库。该目录下会生成一个<code>.git</code> 目录。几乎所有 Git 存储和操作的内容都位于<code>.git</code>目录下，如果你要备份或复制一个库，基本上将这一目录拷贝至其他地方就可以了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git clone [仓库url] &lt;本地目录名&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 支持多种协议，例如：</span><br><span class=\"line\">$ git clone http&lt;s&gt;://example.com/path/to/repo.git/</span><br><span class=\"line\">$ git clone ssh://example.com/path/to/repo.git/</span><br><span class=\"line\">$ git clone &lt;user@&gt;example.com:path/to/repo.git/</span><br><span class=\"line\">$ git clone git://example.com/path/to/repo.git/</span><br><span class=\"line\">$ git clone /opt/git/project.git </span><br><span class=\"line\">$ git clone file:///opt/git/project.git</span><br><span class=\"line\">$ git clone ftp&lt;s&gt;://example.com/path/to/repo.git/</span><br><span class=\"line\">$ git clone rsync://example.com/path/to/repo.git/</span><br></pre></td></tr></table></figure>\n<p>该命令会在本地主机生成一个目录，包含该仓库所有的版本信息。未指定本地名称时，目录名与远程主机的版本库同名。</p>\n<h3 id=\"将修改保存到仓库\"><a href=\"#将修改保存到仓库\" class=\"headerlink\" title=\"将修改保存到仓库\"></a>将修改保存到仓库</h3><p><code>git add</code>命令用于将修改记录到暂存区，之前未进入版本库的新文件也会变成<code>已暂存</code>状态，格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 添加指定文件到暂存区</span><br><span class=\"line\">$ git add &lt;file1&gt; &lt;file2&gt; &lt;...&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加指定目录到暂存区，包括子目录</span><br><span class=\"line\">$ git add &lt;dir&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加当前目录的所有文件到暂存区</span><br><span class=\"line\">$ git add .</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加当前目录的所有.js文件到暂存区</span><br><span class=\"line\">$ git add *.js</span><br></pre></td></tr></table></figure></p>\n<p>要查看哪些文件处于什么状态，可以用 <code>git status</code> 命令。<br>反向操作（暂存区-&gt;工作区）使用<code>rm</code>命令，格式相同。</p>\n<p><code>git commit</code>命令将暂存区的文件保存到仓库，格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 提交暂存区到仓库区，message是提交日志</span><br><span class=\"line\">$ git commit &lt;-m [message]&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 提交暂存区的指定文件到仓库区</span><br><span class=\"line\">$ git commit &lt;[file1] [file2] ... -m [message]&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 跳过暂存操作，把所有已跟踪的文件暂存起来一并提交</span><br><span class=\"line\">$ git commit -a</span><br></pre></td></tr></table></figure>\n<p>如果commit之后不添加<code>-m</code>参数，将进入文本编辑模式输入提交日志。<br><strong>注意：如果是新增文件，那么Git并不会自动添加跟踪，此时跳过add直接commit可能会漏掉。</strong></p>\n<h3 id=\"查看提交历史\"><a href=\"#查看提交历史\" class=\"headerlink\" title=\"查看提交历史\"></a>查看提交历史</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git log</span><br></pre></td></tr></table></figure>\n<p>默认不用任何参数的话，git会按提交时间列出所有的记录，最近的更新排在最上面。其他参数的使用详见<a href=\"https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2\" target=\"_blank\" rel=\"noopener\">官方教程</a>。</p>\n<h3 id=\"使用分支\"><a href=\"#使用分支\" class=\"headerlink\" title=\"使用分支\"></a>使用分支</h3><p>实际工作中各需求基本都是并行开发的，需要用不同的分支来区分不同的工作。Git的特性鼓励在工作流程中频繁地使用分支与合并，因为分支只是一个指向某次提交记录的可变指针，所以可以快速创建合并和删除。<br>常用的基本分支相关操作如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 列出所有本地分支，当前分支前面有*标记</span><br><span class=\"line\">$ git branch</span><br><span class=\"line\"></span><br><span class=\"line\"># 从当前分支的最新提交新建一个分支，但依然停留在当前分支</span><br><span class=\"line\">$ git branch [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 从当前分支的最新提交新建一个分支，并切换到该分支</span><br><span class=\"line\">$ git checkout -b [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 从当前分支的指定提交新建一个分支</span><br><span class=\"line\">$ git branch [branch-name] [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 切换到指定分支，并更新工作区</span><br><span class=\"line\">$ git checkout [branch-name]</span><br><span class=\"line\"></span><br><span class=\"line\"># 合并指定分支到当前分支</span><br><span class=\"line\">$ git merge [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 选择一个commit，合并进当前分支</span><br><span class=\"line\">$ git cherry-pick [commit]</span><br><span class=\"line\"></span><br><span class=\"line\"># 删除分支</span><br><span class=\"line\">$ git branch -d [branch-name]</span><br></pre></td></tr></table></figure>\n<p><strong>注意：分支切换会改变工作区的文件，切换分支时最好保持一个干净的工作区。一些GUI工具会在工作区有未提交文件时阻止用户切换分支。</strong><br>切换分支时，工作区可以用以下几种处理方式清理：  </p>\n<ol>\n<li>直接提交已修改的文件，当工作区还包含未完成的工作时显得不太规范；</li>\n<li>使用<code>git stage</code>命令，将更改<code>贮存</code>起来，使工作区恢复到最近一次提交后的状态。</li>\n</ol>\n<h3 id=\"远程仓库使用\"><a href=\"#远程仓库使用\" class=\"headerlink\" title=\"远程仓库使用\"></a>远程仓库使用</h3><p>实际工作中多人协作时需要有一个远程仓库来保持所有人的代码仓库同步。Git的分布式特性决定了远程仓库与本地仓库并没有什么本质上的区别，并没有中央版本的概念。常说的<code>拉取</code>和<code>推送</code>操作实际上是远程分支和本地分支的<code>合并</code>操作。以下命令可以查看远程分支。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 列出所有远程分支</span><br><span class=\"line\">$ git branch -r</span><br><span class=\"line\"></span><br><span class=\"line\"># 列出所有本地分支和远程分支</span><br><span class=\"line\">$ git branch -a</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"远程主机命名\"><a href=\"#远程主机命名\" class=\"headerlink\" title=\"远程主机命名\"></a>远程主机命名</h4><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令用于管理主机名。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 不带选项的时候列出所有远程主机</span><br><span class=\"line\">$ git remote</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用-v选项查看远程主机的地址</span><br><span class=\"line\">$ git remote -v</span><br><span class=\"line\"></span><br><span class=\"line\"># 添加远程主机</span><br><span class=\"line\">$ git remote add &lt;主机名&gt; &lt;地址&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看远程主机的详细信息</span><br><span class=\"line\">$ git remote show &lt;主机名&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># 更改主机名</span><br><span class=\"line\">$ git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"获取远程更新\"><a href=\"#获取远程更新\" class=\"headerlink\" title=\"获取远程更新\"></a>获取远程更新</h4><p>将远程主机的更新取回本地，使用<code>git fetch</code>命令。命令执行完成后，将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。取回的更新对本地工作区没有影响。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br></pre></td></tr></table></figure></p>\n<p>如果有一个本地分支设置为<code>跟踪</code>一个远程分支（将在下一节详细说明），可以使用<code>git pull</code>命令来自动的获取然后合并远程分支到当前分支。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 跟踪后可以省略本地分支名</span><br><span class=\"line\">$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;&lt;:本地分支名&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>注意: 实质上，pull等同于先做fetch，再merge到当前分支，相当于执行</strong> </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git fetch &lt;远程主机名&gt;</span><br><span class=\"line\">$ git merge &lt;远程主机名/分支名&gt;</span><br></pre></td></tr></table></figure>\n<p><strong>merge过程可能需要处理冲突。</strong></p>\n<h4 id=\"将本地更改推送到远程\"><a href=\"#将本地更改推送到远程\" class=\"headerlink\" title=\"将本地更改推送到远程\"></a>将本地更改推送到远程</h4><p>使用<code>git push</code>命令将本地更新推送到远程后，小伙伴才能获取你的代码，命令格式如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 上传本地指定分支到远程仓库，如果远程没有该分支，会新建一个</span><br><span class=\"line\">$ git push [remote] [branch]</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送所有分支到远程仓库</span><br><span class=\"line\">$ git push [remote] --all</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：远程可能有别的小伙伴先于你更新了远程分支，所以每次推送前需要先获取远程更新，保证本地分支历史是最新的，才能推送本地更新</strong>    </p>\n<h3 id=\"使用标签\"><a href=\"#使用标签\" class=\"headerlink\" title=\"使用标签\"></a>使用标签</h3><p>Git可以对某一时间点上的版本打上标签，让该版本更容易被找到，一般用于发布线上更新的版本。标签相关命令格式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 列出所有标签</span><br><span class=\"line\">$ git tag</span><br><span class=\"line\"></span><br><span class=\"line\"># 使用通配符搜索模式列出符合条件的标签</span><br><span class=\"line\">$ git tag -l &apos;v1.4.2.*&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建轻量级标签“v1.4”</span><br><span class=\"line\">$ git tag v1.4</span><br><span class=\"line\"></span><br><span class=\"line\"># 新建含有附注的标签</span><br><span class=\"line\">$ git tag -a v1.4 -m &apos;my version 1.4&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"># 给指定提交打标签</span><br><span class=\"line\">$git tag -a v1.2 9fceb02</span><br><span class=\"line\"></span><br><span class=\"line\"># 查看指定标签的版本信息</span><br><span class=\"line\">$ git show v1.4</span><br></pre></td></tr></table></figure>\n<p>默认情况下，<code>git push</code>不会推送标签。如果想把本地标签分享到远程仓库，可以使用以下命令：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 推送指定标签到远程</span><br><span class=\"line\">$git push origin [tagname]</span><br><span class=\"line\"></span><br><span class=\"line\"># 推送所有新增标签到远程</span><br><span class=\"line\">$ git push origin --tags</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"进阶操作\"><a href=\"#进阶操作\" class=\"headerlink\" title=\"进阶操作\"></a>进阶操作</h2><p>主要介绍用于整理提交线图的<code>rebase</code>魔法，以及获取其他分支部分提交的<code>cherry pick</code>操作。</p>\n<h3 id=\"rebase相关操作\"><a href=\"#rebase相关操作\" class=\"headerlink\" title=\"rebase相关操作\"></a>rebase相关操作</h3><h4 id=\"pull参数\"><a href=\"#pull参数\" class=\"headerlink\" title=\"pull参数\"></a>pull参数</h4><p>获取远程更新时，直接执行<code>git pull</code>命令可能会获得如下提交线图：<br><img src=\"http://ww4.sinaimg.cn/large/a74e55b4jw1dvnhy8lfndj.jpg\" alt=\"默认pull命令\"><br>可以看到，图中有很多<code>merge xxx</code>提交点。这些提交点并没有实质上的内容更新，而是合并分支时使用默认的<code>merge</code>策略产生的合并点，这样的提交历史看上去较为混乱、不易阅读。如果想让提交线图变得整洁（保持直线的状态），可以使用<code>git pull --rebase</code>命令。<br>假设拉取代码之前分支情况如下：  </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">      A---B---C  remotes/origin/master</span><br><span class=\"line\">     /</span><br><span class=\"line\">D---E---F---G  master</span><br></pre></td></tr></table></figure>\n<p>使用默认策略自动合并时，提交线图会变成以下形状：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">      A---B---C  remotes/origin/master</span><br><span class=\"line\">     /         \\</span><br><span class=\"line\">D---E---F---G---H  master</span><br></pre></td></tr></table></figure>\n<p>H就是多出来的<code>merge xxx</code>提交点。如果是执行 <code>git pull --rebase</code> ，提交线图就会变成线性：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">            remotes/origin/master</span><br><span class=\"line\">                |</span><br><span class=\"line\">D---E---A---B---C---F&apos;---G&apos;  master</span><br></pre></td></tr></table></figure>\n<p>加上<code>--rebase</code>参数时，Git首先将master分支重置到E提交点，将提交ABC合并进来，再重演FG两个提交点，最终合并为一条直线。由于每一步都重新提交，rebase策略可能会有更多的冲突。</p>\n<h4 id=\"交互式rebase清理本地分支\"><a href=\"#交互式rebase清理本地分支\" class=\"headerlink\" title=\"交互式rebase清理本地分支\"></a>交互式rebase清理本地分支</h4><p>如果发现已经提交但还没推送到远程的内容需要更改，可以通过<code>交互式rebase</code>来整理。完整命令如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#将分支[branch]自上次推送起的所有提交进行rebase</span><br><span class=\"line\">$ git rebase -i [branch]</span><br><span class=\"line\"></span><br><span class=\"line\">#将当前分支的前n个提交rebase</span><br><span class=\"line\">$ git rebase -i HEAD~n</span><br></pre></td></tr></table></figure></p>\n<p>执行该命令后，预设编辑器会被调用，显示指定分支自上一次推送起的提交内容，类似：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">pick fc62e55 added file_size</span><br><span class=\"line\">pick 9824bf4 fixed little thing</span><br><span class=\"line\">pick 21d80a5 added number to log</span><br><span class=\"line\">pick 76b9da6 added the apply command</span><br><span class=\"line\">pick c264051 Revert &quot;added file_size&quot; - not implemented correctly</span><br><span class=\"line\"></span><br><span class=\"line\"># Rebase f408319..b04dc3d onto f408319</span><br><span class=\"line\">#</span><br><span class=\"line\"># Commands:</span><br><span class=\"line\">#  p, pick = use commit</span><br><span class=\"line\">#  r, reword = use commit, but edit the commit message</span><br><span class=\"line\">#  e, edit = use commit, but stop for amending</span><br><span class=\"line\">#  s, squash = use commit, but meld into previous commit</span><br><span class=\"line\">#  f, fixup = like &quot;squash&quot;, but discard this commit&apos;s log message</span><br><span class=\"line\">#  x, exec = run command (the rest of the line) using shell</span><br><span class=\"line\">#</span><br><span class=\"line\"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class=\"line\"># However, if you remove everything, the rebase will be aborted.</span><br><span class=\"line\">#</span><br></pre></td></tr></table></figure></p>\n<p>提交记录从旧到新显示（与<code>git log</code>命令的显示顺序相反），在编辑器中可以对选择每个提交执行不同的操作：<br><strong>pick</strong>    :使用该提交<br><strong>reword</strong>  :使用该提交但需要重新编辑提交信息。<br><strong>edit</strong>    :使用该提交，但在应用提交前暂停并进入编辑状态，可以更改提交内容。<br><strong>squash</strong>  :使用该提交并将该提交与前一个提交合并。<br><strong>fixup</strong>   :与squash类似，但不保留该提交的信息。<br><strong>exec</strong>    :通过执行脚本修改提交。<br><strong>整行删除</strong> :丢弃提交。</p>\n<p>编辑文档后保存，Git会按照指令处理所有提交。如果有冲突或更改了提交（比如重新add），更改完成后，使用<code>git rebase --continue</code>指令继续当前rebase操作，直到所有指令完成。</p>\n<h4 id=\"rebase的风险\"><a href=\"#rebase的风险\" class=\"headerlink\" title=\"rebase的风险\"></a>rebase的风险</h4><p><code>rebase</code>操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。 如果已经将提交推送至远程仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 <code>git rebase</code> 命令重新整理了提交并再次推送，其他同伴将不得不再次将他们手头的工作与你的新提交整合，如果接下来你还要拉取并整合他们修改过的提交，可能会产生更多的冲突。因此，使用rebase操作的原则是：   </p>\n<blockquote>\n<blockquote>\n<p>不要对在你的本地仓库外<strong>有副本</strong>的分支执行变基。</p>\n</blockquote>\n</blockquote>\n<p>另外，如果想取消rebase操作，可以在中途随时使用<code>git rebase --abort</code>指令终止rebase，仓库会恢复到rebase开始前的状态。 </p>\n<h3 id=\"cherry-pick\"><a href=\"#cherry-pick\" class=\"headerlink\" title=\"cherry pick\"></a>cherry pick</h3><p>如果要获取其他分支的一些提交，但又不方便将整个分支合并，可以使用<code>cherry pick</code>功能，相当于将其他分支的某个提交在当前分支重新提交一次。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 选取commit id加入当前分支</span><br><span class=\"line\">git cherry-pick [commit id]</span><br></pre></td></tr></table></figure></p>\n<p>执行命令后可能会有冲突需要手动解决，解决后再执行<code>git add</code>和<code>git commit</code>将更改后的文件加入版本控制。继续pick下一个commit，如果提示<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">error: a cherry-pick or revert is already in progress</span><br><span class=\"line\">hint: try &quot;git cherry-pick (--continue | --quit | --abort)&quot;</span><br><span class=\"line\">fatal: cherry-pick failed</span><br></pre></td></tr></table></figure></p>\n<p>则使用对应命令继续/退出/回退选取操作，与rebase操作类似。</p>\n<p>当执行完 <code>cherry-pick</code> 以后，将会生成一个<strong>新的提交</strong>；这个新的提交的哈希值和原来的不同，但标识名一样。如果想保留原作者信息，可以加入<code>-x</code>参数。</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%85%B3%E4%BA%8E%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6\" target=\"_blank\" rel=\"noopener\">git官方文档</a><br><a href=\"http://hungyuhei.github.io/2012/08/07/better-git-commit-graph-using-pull---rebase-and-merge---no-ff.html\" target=\"_blank\" rel=\"noopener\">洁癖者用Git：pull –rebase 和merge –no-ff</a><br><a href=\"https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase-%E7%9A%84%E9%80%89%E6%8B%A9\" target=\"_blank\" rel=\"noopener\">代码合并：Merge、Rebase 的选择</a><br><a href=\"https://www.jianshu.com/p/08c3f1804b36\" target=\"_blank\" rel=\"noopener\">git cherry-pick 使用指南</a></p>\n","prev":{"title":"前端存储","slug":"前端存储"}}