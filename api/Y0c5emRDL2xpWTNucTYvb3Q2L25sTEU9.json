{"title":"前端路由","date":"2018-03-19T01:29:32.587Z","excerpt":"","slug":"前端路由","comments":true,"tags":["前端路由","SPA"],"categories":["SPA"],"updated":"2018-03-23T09:47:37.472Z","content":"<p>web应用中的<strong>路由</strong>是指根据不同的url地址展示不同的内容或页面。过去路由都是由服务端控制，随着SPA兴起，前端也常常负责路由控制，“更新视图但不重新请求页面”是前端路由原理的核心之一。</p>\n<h2 id=\"基于hash的实现\"><a href=\"#基于hash的实现\" class=\"headerlink\" title=\"基于hash的实现\"></a>基于hash的实现</h2><p>这里的<code>hash</code>指的是url地址<code>#</code>后面的内容，可以通过<code>window.location.hash</code>来访问。</p>\n<h3 id=\"hash的特点\"><a href=\"#hash的特点\" class=\"headerlink\" title=\"hash的特点\"></a>hash的特点</h3><p><code>hash</code>有如下特点：</p>\n<ol>\n<li>hash值改变不会引起页面刷新</li>\n<li>hash值改变会在浏览器历史记录中新增记录，可以通过浏览器的前进后退按钮切换</li>\n<li>hash值改变会触发<code>hashchange</code>事件</li>\n</ol>\n<p>所以前端能通过javascript监听hashchange事件，根据hash值的不同来分发路由。</p>\n<p>改变hash有两种方式，其一是通过<code>a</code>标签的<code>href</code>值，由用户点击触发：<br><figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"#ahahahaha\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>另一种是通过js直接修改<code>window.location.hash</code>的值：<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.location.hash = <span class=\"string\">\"ahahahaa\"</span></span><br><span class=\"line\"><span class=\"comment\">// 如果传入数字，也会自动转为字符串</span></span><br></pre></td></tr></table></figure></p>\n<p><strong>注意：如果是通过<code>a</code>标签改变hash，则“#”是必须的，以区分是页内锚点hash还是整体url修改。</strong></p>\n<h3 id=\"监听hash分发路由的实例\"><a href=\"#监听hash分发路由的实例\" class=\"headerlink\" title=\"监听hash分发路由的实例\"></a>监听hash分发路由的实例</h3><p>绑定hashchange事件，在事件回调中改变页面内容，就可以实现一个简单的路由模块：<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Router</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = <span class=\"string\">''</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Router.prototype.route = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">path, callback</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[path] = callback || <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Router.prototype.refresh = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 刷新时的路由规则</span></span><br><span class=\"line\">    <span class=\"keyword\">this</span>.currentUrl = <span class=\"built_in\">window</span>.location.hash.slice(<span class=\"number\">1</span>) || <span class=\"string\">'/'</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.routes[<span class=\"keyword\">this</span>.currentUrl]();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">Router.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始化，绑定change事件</span></span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'load'</span>, <span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">    <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'hashchange'</span>, <span class=\"keyword\">this</span>.refresh.bind(<span class=\"keyword\">this</span>), <span class=\"literal\">false</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.Router = <span class=\"keyword\">new</span> Router();</span><br><span class=\"line\"><span class=\"comment\">// 添加路由规则</span></span><br><span class=\"line\">Router.route(<span class=\"string\">'/'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置响应内容</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">Router.route(<span class=\"string\">'/blue'</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 设置响应内容</span></span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">window</span>.Router.init();</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"基于History-API实现\"><a href=\"#基于History-API实现\" class=\"headerlink\" title=\"基于History API实现\"></a>基于History API实现</h2><p>HTML5标准的history对象新增的<code>pushState</code>和<code>replaceState</code>两个API，都会操作浏览器的历史记录和url而不引起页面的刷新，结合<code>popstate</code>事件监听，可以实现前端路由。和hash不同的是，手动的进行<code>pushState()</code>并不会触发<code>popstate</code>事件。</p>\n<h3 id=\"接口参数\"><a href=\"#接口参数\" class=\"headerlink\" title=\"接口参数\"></a>接口参数</h3><p><code>pushState</code>和<code>replaceState</code>都接收3个参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stateObj = &#123;</span><br><span class=\"line\">    id: <span class=\"number\">2</span>,</span><br><span class=\"line\">    name: <span class=\"string\">\"profile\"</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.pushState(stateObject, title, url);</span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.replaceState(stateObject, title, url);</span><br><span class=\"line\"><span class=\"string\">``</span><span class=\"string\">`  </span></span><br><span class=\"line\"><span class=\"string\">其中，pushState会往历史记录栈顶层新增记录，而replaceState会替换顶层的记录。  </span></span><br><span class=\"line\"><span class=\"string\">**stateObject** </span></span><br><span class=\"line\"><span class=\"string\">    :  一个JS对象，push操作后与当前历史记录关联，无论何时用户导航到这个新创建的状态，会触发`</span>popstate<span class=\"string\">`事件，并能在事件中使用该对象，相当于历史记录的缓存区。  </span></span><br><span class=\"line\"><span class=\"string\">**title**</span></span><br><span class=\"line\"><span class=\"string\">    :  传入一个短标题给当前state。现在大多数浏览器不支持或者会忽略此参数，最好传入null代替。   </span></span><br><span class=\"line\"><span class=\"string\">**url**</span></span><br><span class=\"line\"><span class=\"string\">    :  新的历史记录条目对应的地址，不一定是绝对路径。如果是相对路径，它将以当前URL为基准。传入的URL与当前URL应该是同源的，否则pushState()会抛出异常。该参数是可选的，不指定的话则为文档当前URL。  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">当用户点击浏览器的前进/后退按钮时，就会触发popstate事件，事件参数`</span>e.state<span class=\"string\">`就是在pushState()中存入的第一个参数对象。这个对象可以携带一些简单数据，可用于保存页面对象。</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">### 基于History API的实例</span></span><br><span class=\"line\"><span class=\"string\">`</span><span class=\"string\">``</span>javascript</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Route</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">constructor</span> (routeMap) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.routeMap = routeMap;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>._bindPopState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    init (path) &#123;</span><br><span class=\"line\">        path = Route.correctPath(path);</span><br><span class=\"line\">        history.replaceState(&#123;<span class=\"attr\">path</span>: path&#125;, <span class=\"string\">''</span>, path);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.routeMap[path] &amp;&amp; <span class=\"keyword\">this</span>.routeMap[path]();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    go (path) &#123;</span><br><span class=\"line\">        path = Route.correctPath(path);</span><br><span class=\"line\">        history.pushState(&#123;<span class=\"attr\">path</span>: path&#125;, <span class=\"string\">''</span>, path);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.routeMap[path] &amp;&amp; <span class=\"keyword\">this</span>.routeMap[path]();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _bindPopState () &#123;</span><br><span class=\"line\">        <span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">'popstate'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">           <span class=\"keyword\">const</span> path = e.state &amp;&amp; e.state.path;</span><br><span class=\"line\">           <span class=\"keyword\">this</span>.routeMap[path] &amp;&amp; <span class=\"keyword\">this</span>.routeMap[path]();</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">static</span> correctPath (path) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (path !== <span class=\"string\">'/'</span> &amp;&amp; path.slice(<span class=\"number\">-1</span>) === <span class=\"string\">'/'</span>) &#123;</span><br><span class=\"line\">            path = path.match(<span class=\"regexp\">/(.+)\\/$/</span>)[<span class=\"number\">1</span>];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> path;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> routeMap = &#123;</span><br><span class=\"line\">    <span class=\"string\">'/'</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//主页处理逻辑</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">'/profile'</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//profile页面处理逻辑</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">'/articles'</span>: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//article页面处理逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> router = <span class=\"keyword\">new</span> Route(routeMap);</span><br><span class=\"line\">router.init(location.pathname);</span><br><span class=\"line\">$(<span class=\"string\">'.menu'</span>).addEventListener(<span class=\"string\">'click'</span>, (e) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"comment\">//拦截a标签的默认跳转操作</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (e.target.tagName === <span class=\"string\">'A'</span>) &#123;</span><br><span class=\"line\">        e.preventDefault();</span><br><span class=\"line\">        router.go(e.target.getAttribute(<span class=\"string\">'href'</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"两种方式的对照\"><a href=\"#两种方式的对照\" class=\"headerlink\" title=\"两种方式的对照\"></a>两种方式的对照</h2><ul>\n<li>hash方式兼容性更好，支持IE8+浏览器</li>\n<li>history API可以保存更多数据，但只支持IE10+浏览器</li>\n<li>hash方式的url只支持带“#”的锚点</li>\n<li>history API可以支持任意格式的url（但不能跨域）</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://github.com/kaola-fed/blog/issues/137\" target=\"_blank\" rel=\"noopener\">浅谈前端路由</a><br><a href=\"https://xwjgo.github.io/2017/08/29/history%E5%AE%9E%E7%8E%B0%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/\" target=\"_blank\" rel=\"noopener\">history实现一个前端路由</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Events/hashchange\" target=\"_blank\" rel=\"noopener\">MDN文档-hashchange事件</a><br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/History\" target=\"_blank\" rel=\"noopener\">MDN文档-History API</a></p>\n","next":{"title":"前端存储","slug":"前端存储"}}